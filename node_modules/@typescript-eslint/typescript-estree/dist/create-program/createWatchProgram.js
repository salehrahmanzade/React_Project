"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProgramsForProjects = exports.createWatchProgram = exports.clearCaches = void 0;
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const semver_1 = __importDefault(require("semver"));
const ts = __importStar(require("typescript"));
const shared_1 = require("./shared");
const log = debug_1.default('typescript-eslint:typescript-estree:createWatchProgram');
/**
 * Maps tsconfig paths to their corresponding file contents and resulting watches
 */
const knownWatchProgramMap = new Map();
/**
 * Maps file/folder paths to their set of corresponding watch callbacks
 * There may be more than one per file/folder if a file/folder is shared between projects
 */
const fileWatchCallbackTrackingMap = new Map();
const folderWatchCallbackTrackingMap = new Map();
/**
 * Stores the list of known files for each program
 */
const programFileListCache = new Map();
/**
 * Caches the last modified time of the tsconfig files
 */
const tsconfigLastModifiedTimestampCache = new Map();
const parsedFilesSeenHash = new Map();
/**
 * Clear all of the parser caches.
 * This should only be used in testing to ensure the parser is clean between tests.
 */
function clearCaches() {
    knownWatchProgramMap.clear();
    fileWatchCallbackTrackingMap.clear();
    folderWatchCallbackTrackingMap.clear();
    parsedFilesSeenHash.clear();
    programFileListCache.clear();
    tsconfigLastModifiedTimestampCache.clear();
}
exports.clearCaches = clearCaches;
function saveWatchCallback(trackingMap) {
    return (fileName, callback) => {
        const normalizedFileName = shared_1.getCanonicalFileName(fileName);
        const watchers = (() => {
            let watchers = trackingMap.get(normalizedFileName);
            if (!watchers) {
                watchers = new Set();
                trackingMap.set(normalizedFileName, watchers);
            }
            return watchers;
        })();
        watchers.add(callback);
        return {
            close: () => {
                watchers.delete(callback);
            },
        };
    };
}
/**
 * Holds information about the file currently being linted
 */
const currentLintOperationState = {
    code: '',
    filePath: '',
};
/**
 * Appropriately report issues found when reading a config file
 * @param diagnostic The diagnostic raised when creating a program
 */
function diagnosticReporter(diagnostic) {
    throw new Error(ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine));
}
/**
 * Hash content for compare content.
 * @param content hashed contend
 * @returns hashed result
 */
function createHash(content) {
    var _a;
    // No ts.sys in browser environments.
    if ((_a = ts.sys) === null || _a === void 0 ? void 0 : _a.createHash) {
        return ts.sys.createHash(content);
    }
    return content;
}
function updateCachedFileList(tsconfigPath, program, extra) {
    const fileList = extra.EXPERIMENTAL_useSourceOfProjectReferenceRedirect
        ? new Set(program.getSourceFiles().map(sf => shared_1.getCanonicalFileName(sf.fileName)))
        : new Set(program.getRootFileNames().map(f => shared_1.getCanonicalFileName(f)));
    programFileListCache.set(tsconfigPath, fileList);
    return fileList;
}
/**
 * Calculate project environments using options provided by consumer and paths from config
 * @param code The code being linted
 * @param filePathIn The path of the file being parsed
 * @param extra.tsconfigRootDir The root directory for relative tsconfig paths
 * @param extra.projects Provided tsconfig paths
 * @returns The programs corresponding to the supplied tsconfig paths
 */
function getProgramsForProjects(code, filePathIn, extra) {
    const filePath = shared_1.getCanonicalFileName(filePathIn);
    const results = [];
    // preserve reference to code and file being linted
    currentLintOperationState.code = code;
    currentLintOperationState.filePath = filePath;
    // Update file version if necessary
    const fileWatchCallbacks = fileWatchCallbackTrackingMap.get(filePath);
    const codeHash = createHash(code);
    if (parsedFilesSeenHash.get(filePath) !== codeHash &&
        fileWatchCallbacks &&
        fileWatchCallbacks.size > 0) {
        fileWatchCallbacks.forEach(cb => cb(filePath, ts.FileWatcherEventKind.Changed));
    }
    /*
     * before we go into the process of attempting to find and update every program
     * see if we know of a program that contains this file
     */
    for (const [tsconfigPath, existingWatch] of knownWatchProgramMap.entries()) {
        let fileList = programFileListCache.get(tsconfigPath);
        let updatedProgram = null;
        if (!fileList) {
            updatedProgram = existingWatch.getProgram().getProgram();
            fileList = updateCachedFileList(tsconfigPath, updatedProgram, extra);
        }
        if (fileList.has(filePath)) {
            log('Found existing program for file. %s', 