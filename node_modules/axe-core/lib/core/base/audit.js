import Rule from './rule';
import Check from './check';
import standards from '../../standards';
import RuleResult from './rule-result';
import {
	clone,
	queue,
	preload,
	findBy,
	ruleShouldRun,
	performanceTimer
} from '../utils';
import doT from '@deque/dot';
import log from '../log';
import constants from '../constants';

const dotRegex = /\{\{.+?\}\}/g;

/*eslint no-unused-vars: 0*/
function getDefaultConfiguration(audit) {
	var config;
	if (audit) {
		config = clone(audit);
		// Commons are configured into axe like everything else,
		// however because things go funky if we have multiple commons objects
		// we're not using the copy of that.
		config.commons = audit.commons;
	} else {
		config = {};
	}

	config.reporter = config.reporter || null;
	config.rules = config.rules || [];
	config.checks = config.checks || [];
	config.data = { checks: {}, rules: {}, ...config.data };
	return config;
}

function unpackToObject(collection, audit, method) {
	var i, l;
	for (i = 0, l = collection.length; i < l; i++) {
		audit[method](collection[i]);
	}
}

/**
 * Merge two check locales (a, b), favoring `b`.
 *
 * Both locale `a` and the returned shape resemble:
 *
 *    {
 *      impact: string,
 *      messages: {
 *        pass: string | function,
 *        fail: string | function,
 *        incomplete: string | {
 *          [key: string]: string | function
 *        }
 *      }
 *    }
 *
 * Locale `b` follows the `axe.CheckLocale` shape and resembles:
 *
 *    {
 *      pass: string,
 *      fail: string,
 *      incomplete: string | { [key: string]: string }
 *    }
 */

const mergeCheckLocale = (a, b) => {
	let { pass, fail } = b;
	// If the message(s) are Strings, they have not yet been run
	// thru doT (which will return a Function).
	if (typeof pass === 'string' && dotRegex.test(pass)) {
		pass = doT.compile(pass);
	}
	if (typeof fail === 'string' && dotRegex.test(fail)) {
		fail = doT.compile(fail);
	}
	return {
		...a,
		messages: {
			pass: pass || a.messages.pass,
			fail: fail || a.messages.fail,
			incomplete:
				typeof a.messages.incomplete === 'object'
					? // TODO: for compleness-sake, we should be running
					  // incomplete messages thru doT as well. This was
					  // out-of-scope for runtime localization, 